// The test-splitter tool fetches and runs test plans generated by Buildkite
// Test Splitting.
package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"time"

	"github.com/buildkite/test-splitter/internal/api"
	"github.com/buildkite/test-splitter/internal/config"
	"github.com/buildkite/test-splitter/internal/plan"
	"github.com/buildkite/test-splitter/internal/runner"
)

// other attributes are omitted for simplicity
type Example struct {
	FilePath string `json:"file_path"`
}

// other attributes are omitted for simplicity
type RspecData struct {
	Examples []Example `json:"examples"`
}

func main() {
	// TODO: detect test runner and use appropriate runner
	testRunner := runner.Rspec{}

	// get files
	fmt.Println("--- :test-analytics: Gathering test plan context and creating test plan request üêøÔ∏è")
	files, err := testRunner.GetFiles()
	if err != nil {
		log.Fatalf("Couldn't get files: %v", err)
	}
	fmt.Printf("Found %d files\n", len(files))

	// get config
	cfg, err := config.New()
	if err != nil {
		log.Fatal("Invalid configuration: ", err)
	}

	// get plan
	fmt.Println("--- :test-analytics: Getting Test Plan üé£")
	fmt.Printf("config: %+v", cfg)

	testCases := []plan.TestCase{}
	for _, file := range files {
		testCases = append(testCases, plan.TestCase{
			Path: file,
		})
	}

	ctx := context.Background()

	fetchCtx, cancel := context.WithTimeout(ctx, 1*time.Minute)
	defer cancel()

	tests := plan.Tests{
		Cases:  testCases,
		Format: "files",
	}
	testPlan, err := api.FetchTestPlan(fetchCtx, cfg.ServerBaseUrl, api.TestPlanParams{
		SuiteToken:  cfg.SuiteToken,
		Mode:        cfg.Mode,
		Identifier:  cfg.Identifier,
		Parallelism: cfg.Parallelism,
		Tests:       tests,
	})
	if err != nil {
		// Didn't run out of retries? Must have been some kind of error that
		// means we should abort.
		if !errors.Is(err, api.ErrRetryLimitExceeded) {
			log.Fatalf("Couldn't fetch test plan: %v", err)
		}
		// Create the fallback plan
		testPlan = plan.CreateFallbackPlan(tests, cfg.Parallelism)
	}

	// get plan for this node
	thisNodeTask := testPlan.Tasks[strconv.Itoa(cfg.NodeIndex)]

	prettifiedPlan, _ := json.MarshalIndent(thisNodeTask, "", "  ")
	fmt.Println("--- :test-analytics: Plan for this node üéä")
	fmt.Println(string(prettifiedPlan))

	// execute tests
	runnableTests := []string{}
	for _, testCase := range thisNodeTask.Tests.Cases {
		runnableTests = append(runnableTests, testCase.Path)
	}
	cmd := testRunner.Command(runnableTests)

	if err := cmd.Start(); err != nil {
		log.Fatalf("Couldn't start tests: %v", err)
	}

	// Create a channel that will be closed when the command finishes.
	finishCh := make(chan struct{})

	// Start a goroutine to that waits for a signal or the command to finish.
	go func() {
		// Create another channel to receive the signals.
		sigCh := make(chan os.Signal, 1)
		signal.Notify(sigCh)

		// Wait for a signal to be received or the command to finish.
		// Because a message can come through both channels asynchronously,
		// we use for loop to listen to both channels and select the one that has a message.
		// Without for loop, only one case would be selected and the other would be ignored.
		// If the signal is received first, the finishCh will never get processed and the goroutine will run forever.
		for {
			select {
			case sig := <-sigCh:
				// When a signal is received, forward it to the command.
				cmd.Process.Signal(sig)
			case <-finishCh:
				// When the the command finishes, we stop listening for signals and return.
				signal.Stop(sigCh)
				return
			}
		}
	}()

	if err := cmd.Wait(); err != nil {
		if exitError := new(exec.ExitError); errors.As(err, &exitError) {
			exitCode := exitError.ExitCode()
			log.Printf("Rspec exited with error %d", exitCode)
			os.Exit(exitCode)
		}
		log.Fatalf("Couldn't run tests: %v", err)
	}

	// Close the channel that will stop the goroutine.
	close(finishCh)

	fmt.Println("--- :test-analytics: Test execution results üìä")
	err = testRunner.Report(os.Stdout, thisNodeTask.Tests.Cases)
	if err != nil {
		fmt.Println(err)
	}
}
