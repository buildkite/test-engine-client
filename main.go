// The test-splitter tool fetches and runs test plans generated by Buildkite
// Test Splitting.
package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"time"

	"github.com/buildkite/test-splitter/internal/api"
	"github.com/buildkite/test-splitter/internal/config"
	"github.com/buildkite/test-splitter/internal/plan"
	"github.com/buildkite/test-splitter/internal/runner"
)

func main() {
	// TODO: detect test runner and use appropriate runner
	testRunner := runner.Rspec{}

	// get files
	fmt.Println("--- :test-analytics: Gathering test plan context and creating test plan request üêøÔ∏è")
	files, err := testRunner.GetFiles()
	if err != nil {
		log.Fatalf("Couldn't get files: %v", err)
	}
	fmt.Printf("Found %d files\n", len(files))

	// get config
	cfg, err := config.New()
	if err != nil {
		log.Fatal("Invalid configuration: ", err)
	}

	// get plan
	fmt.Println("--- :test-analytics: Getting Test Plan üé£")
	fmt.Printf("config: %+v\n", cfg)

	ctx := context.Background()
	// We expect the whole test plan fetching process takes no more than 60 seconds.
	// Configure the timeout as 70s to give it a bit more buffer.
	fetchCtx, cancel := context.WithTimeout(ctx, 70*time.Second)
	defer cancel()

	testPlan, err := fetchOrCreateTestPlan(fetchCtx, cfg, files)
	if err != nil {
		log.Fatalf("Couldn't create test plan: %v", err)
	}

	// get plan for this node
	thisNodeTask := testPlan.Tasks[strconv.Itoa(cfg.NodeIndex)]

	prettifiedPlan, _ := json.MarshalIndent(thisNodeTask, "", "  ")
	fmt.Println("--- :test-analytics: Plan for this node üéä")
	fmt.Println(string(prettifiedPlan))

	// execute tests
	runnableTests := []string{}
	for _, testCase := range thisNodeTask.Tests.Cases {
		runnableTests = append(runnableTests, testCase.Path)
	}
	cmd := testRunner.Command(runnableTests)

	if err := cmd.Start(); err != nil {
		log.Fatalf("Couldn't start tests: %v", err)
	}

	// Create a channel that will be closed when the command finishes.
	finishCh := make(chan struct{})

	// Start a goroutine to that waits for a signal or the command to finish.
	go func() {
		// Create another channel to receive the signals.
		sigCh := make(chan os.Signal, 1)
		signal.Notify(sigCh)

		// Wait for a signal to be received or the command to finish.
		// Because a message can come through both channels asynchronously,
		// we use for loop to listen to both channels and select the one that has a message.
		// Without for loop, only one case would be selected and the other would be ignored.
		// If the signal is received first, the finishCh will never get processed and the goroutine will run forever.
		for {
			select {
			case sig := <-sigCh:
				// When a signal is received, forward it to the command.
				cmd.Process.Signal(sig)
			case <-finishCh:
				// When the the command finishes, we stop listening for signals and return.
				signal.Stop(sigCh)
				return
			}
		}
	}()

	if err := cmd.Wait(); err != nil {
		if exitError := new(exec.ExitError); errors.As(err, &exitError) {
			exitCode := exitError.ExitCode()
			log.Printf("Rspec exited with error %d", exitCode)
			os.Exit(exitCode)
		}
		log.Fatalf("Couldn't run tests: %v", err)
	}

	// Close the channel that will stop the goroutine.
	close(finishCh)

	fmt.Println("--- :test-analytics: Test execution results üìä")
	err = testRunner.Report(os.Stdout, thisNodeTask.Tests.Cases)
	if err != nil {
		fmt.Println(err)
	}
}

// fetchOrCreateTestPlan fetches a test plan from the server, or creates a
// fallback plan if the server is unavailable or returns an error plan.
func fetchOrCreateTestPlan(ctx context.Context, cfg config.Config, files []string) (plan.TestPlan, error) {
	testCases := []plan.TestCase{}
	for _, file := range files {
		testCases = append(testCases, plan.TestCase{
			Path: file,
		})
	}

	tests := plan.Tests{
		Cases:  testCases,
		Format: "files",
	}

	testPlan, err := api.FetchTestPlan(ctx, cfg.ServerBaseUrl, api.TestPlanParams{
		SuiteToken:  cfg.SuiteToken,
		Mode:        cfg.Mode,
		Identifier:  cfg.Identifier,
		Parallelism: cfg.Parallelism,
		Tests:       tests,
	})

	if err != nil {
		// Didn't exceed context deadline? Must have been some kind of error that
		// means we should return error to main function and abort.
		if !errors.Is(err, context.DeadlineExceeded) {
			return plan.TestPlan{}, err
		}
		// Create the fallback plan
		fmt.Println("Could not fetch plan from server, using fallback mode. Your build may take longer than usual.")
		testPlan = plan.CreateFallbackPlan(tests, cfg.Parallelism)
	}

	// The server can return an "error" plan indicated by an empty task list (i.e. `{"tasks": {}}`).
	// In this case, we should create a fallback plan.
	if len(testPlan.Tasks) == 0 {
		fmt.Println("Test splitter server returned an error, using fallback mode. Your build may take longer than usual.")
		testPlan = plan.CreateFallbackPlan(tests, cfg.Parallelism)
	}

	return testPlan, nil
}
